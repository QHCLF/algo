js主要是依靠原型链来实现继承的
实现继承的方法：
1.原型链继承
    原型链：每一个构造函数都有一个原型对象，原型对象内部存在一个指向构造函数的指针，而这个实例又存在一个指向原型对象指针的指针，因此我们让另外一个类型的原型对象等于这个类型的实例，这样这个 b类型的原型对象的指针就指向了a类型的原型对象的指针，层层递进就形成了原型链
    缺点：1.包含引用类型值的原型属性会被所有实例共享，这也是为什么在构造函数中定义属性而不是在原型中定义的原因，当使用原型链来实现继承是，原型变成了另一个类型的实例，于是原先的父实例属性也就变成了现在的子原型属性了
    2.不能在不影响所有对象实例的情况下，向父类型的构造函数中传递参数
2.借用构造函数继承(经典继承)
在子类构造函数的内部调用父类构造函数通过使用call, apply,实际上就是在创建子类型实例的时候调用的是父类型的构造函数
缺点：方法都在构造函数中定义，函数复用无从谈起，并且超类原型定义方法对于子类都是不可见的，所有类型都只能使用构造函数模式
3.组合式继承(伪经典继承)
使用原型链继承父类型的原型方法，借用构造函数继承夫类型的构造函数
4.原型式继承
思想：借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型
操作：在函数内部创建一个临时性的构造函数，然后传入的对象作为构造函数的原型，最后返回这个临时类型的一个新实例，本质上，就是对这个函数传入其中的对象指向了一次浅赋值
缺点： 的原型属性会被所有实例共享
5.寄生式继承
思路：创建一个仅用于封装继承过程的函数，该函数内部以某种方式来增强对象，最后再像真的是他做了所有工作一样返回对象
6.寄生式组合继承
通过借用构造函数来继承属性，通过原型链的混成形式来继承方法，就是使用寄生式继承来继承超类的原型，在将结果指定给子类的原型